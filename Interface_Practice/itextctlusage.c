
01./*===========================================================================  
02.  
03.FILE: itextctlusage.c  
04.  
05.SERVICES: Sample applet using AEE  
06.  
07.DESCRIPTION  
08.  This file contains usage examples of ITextCtl interface. ITextCtl interface  
09.  functions allow the user to create/operate on ITextCtl objects. ITextCtl  
10.  objects are used to invoke Calender text related functionality.  
11.  
12.PUBLIC CLASSES:    
13.   N/A  
14.  
15.  
16.       Copyright ï¿½ 2000-2001 QUALCOMM Incorporated.  
17.                      All Rights Reserved.  
18.                   QUALCOMM Proprietary/GTDR  
19.===========================================================================*/   
20.   
21./*===============================================================================  
22.                     INCLUDES AND VARIABLE DEFINITIONS  
23.=============================================================================== */   
24.#include "AEEModGen.h"   
25.#include "AEEAppGen.h"   
26.#include "AEEMenu.h"   
27.#include "AEEStdLib.h"   
28.#include "AEEUsageAppIDs.h"   
29.#include "AEEText.h"   
30.   
31.// App resource header generated by BREW ResourceEditor.   
32.#include "itextctl_res.h"   
33.   
34./*===========================================================================  
35.  
36.                      PUBLIC DATA DECLARATIONS  
37.  
38.===========================================================================*/   
39.   
40./*-------------------------------------------------------------------  
41.            Type Declarations  
42.-------------------------------------------------------------------*/   
43.// TextCtl app struct. This is the main struct for this applet. This will hold    
44.// all the data members that needs to be remembered throughout the life of   
45.// the applet.    
46.// THE FIRST DATA MEMBER OF THIS STRUCT MUST BE AN AEEApplet OBJECT.    
47.// This is critical requirement which is related to an applet being   
48.// dynamically loaded. The app developers should add their data members   
49.// following the AEEApplet data member.   
50.typedef struct _CITextCtlApp   
51.{   
52.    AEEApplet   a;        // Mandatory first AEEApplet data member   
53.   IMenuCtl *  m_pIMenu;   
54.   ITextCtl *  m_pIText;   
55.   IMenuCtl *  m_pISoftKey;   
56.   
57.   // Device parameters   
58.   int             m_nLineHeight;   
59.   AEEDeviceInfo   m_dInfo;   
60.   
61.}CITextCtlApp;   
62.   
63./*-------------------------------------------------------------------  
64.            Function Prototypes  
65.-------------------------------------------------------------------*/   
66.// Mandatory function:   
67.// App Handle Event function   
68.static boolean TextCtlApp_HandleEvent(IApplet * pi, AEEEvent eCode, uint16 wParam, uint32 dwParam);   
69.   
70.// App specific data alloc-init/free functions   
71.static boolean ITextCtl_InitAppData(IApplet* pMe);   
72.static void ITextCtl_FreeAppData(IApplet* pMe);   
73.   
74.static void BuildMainMenu(CITextCtlApp *pMe);   
75.static void ITextCtlUsage (CITextCtlApp * pMe, uint16 wParam);   
76.static void DisplayEvent (CITextCtlApp *pMe, uint16 wParam);   
77.static void DisplayOutput(CITextCtlApp * pMe, int nline, char *pszStr);   
78.   
79./*-------------------------------------------------------------------  
80.            Global Constant Definitions  
81.-------------------------------------------------------------------*/   
82.// App Resource File   
83.#define  APP_RES_FILE      "itextctl.bar"   
84.   
85.// App specific constants   
86.#define USAGE_BASIC_USAGE       100   
87.#define USAGE_HANDLEEVENT       101   
88.#define USAGE_REDRAW            102   
89.#define USAGE_SETACTIVE         103   
90.#define USAGE_ISACTIVE          104   
91.#define USAGE_SETRECT           105   
92.#define USAGE_GETRECT           106   
93.#define USAGE_SETPROPERTIES     107   
94.#define USAGE_GETPROPERTIES     108   
95.#define USAGE_RESET             109   
96.#define USAGE_SETTITLE_LOCAL    110   
97.#define USAGE_SETTITLE_RES      111   
98.#define USAGE_SETTEXT           112   
99.#define USAGE_GETTEXT           113   
100.#define USAGE_GETTEXTPTR        114   
101.#define USAGE_ENABLECOMMAND     115   
102.#define USAGE_SETMAXSIZE        116   
103.#define USAGE_SETSOFTKEYMENU    117   
104.   
105./*===============================================================================  
106.                     FUNCTION DEFINITIONS  
107.=============================================================================== */   
108.   
109./*===========================================================================  
110.  
111.FUNCTION: AEEClsCreateInstance  
112.  
113.DESCRIPTION  
114.    This function is invoked while the app is being loaded. All Modules must provide this   
115.    function. Ensure to retain the same name and parameters for this function.  
116.    In here, the module must verify the ClassID and then invoke the AEEApplet_New() function  
117.    that has been provided in AEEAppGen.c.   
118.  
119.   After invoking AEEApplet_New(), this function can do app specific initialization. In this  
120.   example, a generic structure is provided so that app developers need not change app specific  
121.   initialization section every time except for a call to ITextCtl_InitAppData().   
122.   This is done as follows: InitAppData() is called to initialize AppletData   
123.   instance. It is app developers responsibility to fill-in app data initialization   
124.   code of InitAppData(). App developer is also responsible to release memory   
125.   allocated for data contained in AppletData -- this can be done in   
126.   ITextCtl_FreeAppData().  
127.  
128.PROTOTYPE:  
129.   int AEEClsCreateInstance(AEECLSID ClsId,IShell * pIShell,IModule * po,void ** ppObj)  
130.  
131.PARAMETERS:  
132.    clsID: [in]: Specifies the ClassID of the applet which is being loaded  
133.  
134.    pIShell: [in]: Contains pointer to the IShell interface.   
135.  
136.    pIModule: pin]: Contains pointer to the IModule interface to the current module to which  
137.    this app belongs  
138.  
139.    ppObj: [out]: On return, *ppObj must point to a valid IApplet structure. Allocation  
140.    of memory for this structure and initializing the base data members is done by AEEApplet_New().  
141.  
142.DEPENDENCIES  
143.  none  
144.  
145.RETURN VALUE  
146.  AEE_SUCCESS: If the app needs to be loaded and if AEEApplet_New() invocation was  
147.     successful  
148.  EFAILED: If the app does not need to be loaded or if errors occurred in   
149.     AEEApplet_New(). If this function returns FALSE, the app will not be loaded.  
150.  
151.SIDE EFFECTS  
152.  none  
153.===========================================================================*/   
154.int AEEClsCreateInstance(AEECLSID ClsId,IShell * pIShell,IModule * po,void ** ppObj)   
155.{   
156.   *ppObj = NULL;   
157.           
158.   // We want to load this App. So, invoke AEEApplet_New().To it, pass the   
159.   // address of the app-specific handle event function.   
160.   if(ClsId == AEECLSID_TEXTCTL_APP){   
161.      if(AEEApplet_New(sizeof(CITextCtlApp), ClsId, pIShell,po,(IApplet**)ppObj,   
162.         (AEEHANDLER)TextCtlApp_HandleEvent,(PFNFREEAPPDATA)ITextCtl_FreeAppData)   
163.         == TRUE)   
164.      {   
165.         if (ITextCtl_InitAppData((IApplet*)*ppObj) == TRUE)   
166.         {   
167.            return(AEE_SUCCESS);   
168.         }   
169.      }   
170.   }   
171.    return (EFAILED);   
172.}   
173.   
174./*===========================================================================  
175.  
176.FUNCTION TextCtlApp_HandleEvent  
177.  
178.DESCRIPTION  
179.    This is the EventHandler for this app. All events to this app are handled in this  
180.    function. All APPs must supply an Event Handler.  
181.  
182.PROTOTYPE:  
183.    boolean TextCtlApp_HandleEvent(IApplet * pi, AEEEvent eCode, uint16 wParam, uint32 dwParam)  
184.  
185.PARAMETERS:  
186.    pi: Pointer to the AEEApplet structure. This structure contains information specific  
187.    to this applet. It was initialized during the AEEClsCreateInstance() function.  
188.  
189.    ecode: Specifies the Event sent to this applet  
190.  
191.   wParam, dwParam: Event specific data.  
192.  
193.DEPENDENCIES  
194.  none  
195.  
196.RETURN VALUE  
197.  TRUE: If the app has processed the event  
198.  FALSE: If the app did not process the event  
199.  
200.SIDE EFFECTS  
201.  none  
202.===========================================================================*/   
203.static boolean TextCtlApp_HandleEvent(IApplet * pi, AEEEvent eCode, uint16 wParam, uint32 dwParam)   
204.{     
205.   CITextCtlApp * pMe = (CITextCtlApp*)pi;   
206.   
207.   switch (eCode)    
208.    {   
209.   
210.      case EVT_APP_START:   
211.         // Create the IMenu interface object. When the applet is started the    
212.         // main menu is set up. When the user selects a menu item from the main    
213.         // menu, an EVT_COMMAND event is received by this applet. The processing for    
214.         // EVT_COMMAND event is found below.   
215.            if(ISHELL_CreateInstance(pMe->a.m_pIShell, AEECLSID_MENUCTL, (void **)&pMe->m_pIMenu)   
216.            != SUCCESS)   
217.         {   
218.                return FALSE;   
219.         }   
220.   
221.         // Build the main menu   
222.            BuildMainMenu(pMe);   
223.            return(TRUE);   
224.      case EVT_APP_STOP:   
225.         return(TRUE);   
226.      case EVT_KEY:    
227.         // Call the TextCtl HandleEvent to see if this event would be    
228.         // handled by the TextCtl interface. When the Up or Down key is    
229.         // pressed we will fail the check below, release the ITextCtl object   
230.         // and pass the controls to the menu control object.   
231.         if ((pMe->m_pIText != NULL) &&    
232.            ITEXTCTL_HandleEvent(pMe->m_pIText, EVT_KEY, wParam, dwParam))   
233.         {   
234.            // This event was handled by TextCtl. Return here since   
235.            // this was handled by the text control object.   
236.            return TRUE;   
237.         }   
238.   
239.            // Release soft key menu.   
240.            if (pMe->m_pISoftKey != NULL)   
241.            {   
242.                IMENUCTL_Release (pMe->m_pISoftKey);   
243.                pMe->m_pISoftKey = NULL;   
244.            }   
245.   
246.         // Release the ITextCtl object if it is not NULL.   
247.         if (pMe->m_pIText != NULL)   
248.         {   
249.            // We have come here because the TextCtl object was    
250.            // not NULL. This means we would have been in an active edit   
251.            // mode of the Text Control and the select key was pressed   
252.            // (any other key press would have been handled by the Text   
253.            // control.   
254.            ITEXTCTL_Release (pMe->m_pIText);   
255.            pMe->m_pIText = NULL;   
256.            //return TRUE;   
257.         }   
258.   
259.         // We have come here when a key is pressed on the handset keypad. Call    
260.         // the IMenuCtl handle event function to handle this key press.   
261.         // If this key press corressponds to an Up/Down arrow    
262.         // key press, this event will be handled by the IMenuCtl object   
263.         // in moving to the next menu item (in the given direction).    
264.         // If the key is neither Up/Down, the IMenuCtl the key press    
265.         // is not handled, hence, return FALSE.   
266.              if (pMe->m_pIMenu)   
267.              {   
268.                    if ((IMENUCTL_IsActive(pMe->m_pIMenu) == FALSE) && ((wParam == AVK_UP) || (wParam == AVK_DOWN)))   
269.                    {   
270.                        IMENUCTL_SetActive(pMe->m_pIMenu, TRUE);   
271.                        IMENUCTL_Redraw(pMe->m_pIMenu);   
272.                    }   
273.                  return IMENUCTL_HandleEvent(pMe->m_pIMenu, EVT_KEY, wParam, 0);   
274.              }   
275.              else    
276.                  return FALSE;   
277.   
278.        case EVT_COMMAND:   
279.         // When a menu item is selected this applet receives the   
280.         // EVT_COMMAND event in the wParam field.   
281.           switch(wParam)   
282.         {   
283.            case USAGE_BASIC_USAGE:   
284.            case USAGE_HANDLEEVENT:   
285.            case USAGE_REDRAW:   
286.            case USAGE_SETACTIVE:   
287.            case USAGE_ISACTIVE:   
288.            case USAGE_SETRECT:   
289.            case USAGE_GETRECT:   
290.            case USAGE_SETPROPERTIES:   
291.            case USAGE_GETPROPERTIES:   
292.            case USAGE_RESET:   
293.            case USAGE_SETTITLE_LOCAL:   
294.            case USAGE_SETTITLE_RES:   
295.            case USAGE_SETTEXT:   
296.            case USAGE_GETTEXT:   
297.            case USAGE_GETTEXTPTR:   
298.            case USAGE_ENABLECOMMAND:   
299.            case USAGE_SETMAXSIZE:   
300.            case USAGE_SETSOFTKEYMENU:   
301.               // Call the usage function that exercises all the    
302.               // interface functions.   
303.               ITextCtlUsage (pMe, wParam);   
304.               return TRUE;   
305.            default:   
306.                return FALSE;   
307.         }   
308.      default:   
309.         break;   
310.   }   
311.   return FALSE;   
312.}   
313.   
314.   
315.   
316./*===========================================================================  
317.  
318.FUNCTION ITextCtl_InitAppData  
319.  
320.DESCRIPTION  
321.   This function initializes app specific data allocates memory for app data   
322.   (AppletData) and sets it to pAppData of AEEApplet. It also function .   
323.   App developer needs to fill-in the initialization code.  
324.  
325.PROTOTYPE:  
326.    boolean ITextCtl_InitAppData(IApplet* pi);  
327.  
328.PARAMETERS:  
329.    pi [in]: Pointer to the IApplet structure. This structure contains   
330.   information specific to this applet. It was initialized during the   
331.   AEEClsCreateInstance().  
332.  
333.DEPENDENCIES  
334.   Assumes pi is not NULL  
335.  
336.RETURN VALUE  
337.  TRUE: If the app has app data is allocated and initialized successfully  
338.  FALSE: Either app data could not be allocated or initialzied  
339.  
340.SIDE EFFECTS  
341.  none  
342.===========================================================================*/   
343.static boolean ITextCtl_InitAppData(IApplet* pi)   
344.{   
345.   int pnAscent;        // Stores the ascent in number of pixels   
346.   int pnDescent;       // Stores the descent in number of pixels   
347.   
348.   CITextCtlApp * pMe = (CITextCtlApp*)pi;   
349.   
350.   // Initialize the MenuCtl pointer to NULL   
351.   pMe->m_pIMenu = NULL;   
352.   pMe->m_pIText = NULL;   
353.   pMe->m_pISoftKey = NULL;   
354.   
355.   // Get the font metrics info   
356.   pMe->m_nLineHeight = IDISPLAY_GetFontMetrics (pMe->a.m_pIDisplay, AEE_FONT_NORMAL,   
357.      &pnAscent, &pnDescent);   
358.   
359.   ISHELL_GetDeviceInfo(pMe->a.m_pIShell,&pMe->m_dInfo);   
360.   
361.   return TRUE;   
362.}   
363.   
364./*===========================================================================  
365.  
366.FUNCTION ITextCtl_FreeAppData  
367.  
368.DESCRIPTION  
369.   Frees data contained in app data and memory for app data itself.  
370.   App developer needs to free data contained in AppletData.  
371.  
372.PROTOTYPE:  
373.    void ITextCtl_FreeAppData(IApplet* pi);  
374.  
375.PARAMETERS:  
376.    pi [in]: Pointer to the IApplet structure. This structure contains   
377.   information specific to this applet. It was initialized during the   
378.   AEEClsCreateInstance().  
379.  
380.DEPENDENCIES  
381.   Assumes pi is not NULL  
382.  
383.RETURN VALUE  
384.   None  
385.  
386.SIDE EFFECTS  
387.   None  
388.===========================================================================*/   
389.static void ITextCtl_FreeAppData(IApplet* pi)   
390.{   
391.   CITextCtlApp * pMe = (CITextCtlApp*)pi;   
392.   
393.   // Release main menu   
394.   if (pMe->m_pIMenu != NULL)   
395.   {   
396.      IMENUCTL_Release (pMe->m_pIMenu);   
397.      pMe->m_pIMenu = NULL;   
398.   }   
399.   // Release soft key menu.   
400.   if (pMe->m_pISoftKey != NULL)   
401.   {   
402.      IMENUCTL_Release (pMe->m_pISoftKey);   
403.      pMe->m_pISoftKey = NULL;   
404.   }   
405.   // Release TextCtl object if it is not released   
406.   if (pMe->m_pIText != NULL)   
407.   {   
408.      ITEXTCTL_Release (pMe->m_pIText);   
409.      pMe->m_pIText = NULL;   
410.   }   
411.}   
412.   
413./*===============================================================================  
414.                     APP HELPER FUNCTION DEFINITIONS  
415.=============================================================================== */   
416.   
417./*===========================================================================  
418.  
419.FUNCTION: ITextCtlUsage  
420.  
421.DESCRIPTION  
422.    This function encompasses all the usage examples of all the functions  
423.   in code blocks switched using the BREW API function Id passed into this  
424.   function. The code blocks will include almost all the variable declarations  
425.   needed to demonstrate the usage of a given function. Within the code block  
426.   all the needed interfaces are instantiated and released subsequent to their  
427.   use.  
428.  
429.   There are some exceptions to the above general rule, such as call-back functions,  
430.   common helper function, or common display functions called from within the  
431.   code block which are defined elsewhere in this file.  
432.  
433.   There are some instances where an object instantiated within a code block is  
434.   not released at the end of the code block, to be released at a later point  
435.   (for example in a call-back function, in this case pointers to such objects  
436.   are stored in the AEEApplet object to be released later).  
437.     
438.PROTOTYPE:  
439.   void ITextCtlUsage (CITextCtlApp * pMe, uint16 wParam)  
440.  
441.PARAMETERS:  
442.    pMe: [in]: Contains a pointer to the CITextCtlApp struct.  
443.   wParam: [in]: Contains the Id of the function type to be used (contains the  
444.      Id corresponding to the menu item selected on the emulator).  
445.  
446.DEPENDENCIES  
447.  none  
448.  
449.RETURN VALUE  
450.  none  
451.  
452.SIDE EFFECTS  
453.  none  
454.===========================================================================*/   
455.static void ITextCtlUsage (CITextCtlApp * pMe, uint16 wParam)   
456.{   
457.   AEERect rect;   
458.   IShell *pIShell = pMe->a.m_pIShell;   
459.   
460.   // Set rectangle coordinates for a rectangle in the middle of the screen.   
461.   SETAEERECT (&rect, pMe->m_dInfo.cxScreen/8, pMe->m_dInfo.cyScreen/5,    
462.      pMe->m_dInfo.cxScreen*3/4, pMe->m_dInfo.cyScreen/2);   
463.   
464.   // Erase screen first for display output purposes.   
465.   IDISPLAY_ClearScreen (pMe->a.m_pIDisplay);   
466.    IMENUCTL_SetProperties(pMe->m_pIMenu, MP_NO_REDRAW);   
467.    IMENUCTL_SetActive(pMe->m_pIMenu, FALSE);   
468.   
469.   switch (wParam)   
470.   {   
471.      case USAGE_BASIC_USAGE:   
472.         {   
473.            // 1. Usage: Basic ITextCtl Usage   
474.            AECHAR szBuf[50] = {0};   
475.   
476.            // Create ITextCtl object. This step needs to be done only if   
477.            // the ITextCtl object has not been created already.    
478.            //   
479.            // Create an instance of the ITextCtl object and store it in   
480.            // the CITextCtlApp class data member. This is used to better   
481.            // illustrate the ITextCtl object operations.   
482.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pMe->m_pIText);   
483.   
484.            if (pMe->m_pIText)   
485.            {   
486.               // Set title of the menu control object   
487.               STR_TO_WSTR("Title ", szBuf, sizeof(szBuf));   
488.               ITEXTCTL_SetTitle(pMe->m_pIText, NULL, NULL, szBuf);   
489.               // Set maximum text size supported by the text control object   
490.               ITEXTCTL_SetMaxSize(pMe->m_pIText, 100);   
491.   
492.               // Set properties to have thetext control object have a   
493.               // frame and to have a multi-line text edit space.   
494.               ITEXTCTL_SetProperties(pMe->m_pIText,  TP_FRAME | TP_MULTILINE );   
495.               ITEXTCTL_SetRect(pMe->m_pIText, &rect);   
496.   
497.               // Set the initial text of the text control object.   
498.               STR_TO_WSTR("Enter Text..", szBuf, sizeof(szBuf));   
499.               ITEXTCTL_SetText(pMe->m_pIText, szBuf, sizeof (szBuf));   
500.   
501.               // Set the text control object so that the user can edit it's   
502.               // text content.   
503.               ITEXTCTL_SetActive (pMe->m_pIText, TRUE);   
504.   
505.               // The ITextCtl object is NOT released at this point. The ITextCtl    
506.               // object is released in the HandleEvents function under EVT_KEY.    
507.               // This gives the user the ability to edit text on an active    
508.               // ITextCtl object. The ITextCtl object is released when the user    
509.               // selects the Up/Down arrow to move to another main menu selection   
510.               // or when the user exits the applet.   
511.            }   
512.         }   
513.         break;   
514.      case USAGE_HANDLEEVENT:   
515.         {   
516.            // 2. Usage: ITEXTCTL_HandleEvent   
517.            AEEEvent  evt = EVT_KEY;       // TextCtl only supports this event   
518.            uint16    wParam  = AVK_RIGHT;  // Supports SELECT, LEFT, RIGHT, UP, DOWN   
519.            uint32    dwParam = 0;   
520.            AECHAR    szBuf[50] = {0};   
521.   
522.            // Create ITextCtl object. This step needs to be done only if   
523.            // the ITextCtl object has not been created already.    
524.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pMe->m_pIText);   
525.   
526.            if (pMe->m_pIText)   
527.            {   
528.               // SetRect/SetText used for output display purposes only. For more    
529.               // details see ITEXTCTL_SetText/ITEXTCTL_SetRect usage.    
530.               ITEXTCTL_SetRect(pMe->m_pIText, &rect);   
531.               STR_TO_WSTR("HandleEvent Text..", szBuf, sizeof(szBuf));   
532.               ITEXTCTL_SetText(pMe->m_pIText, szBuf, sizeof (szBuf));   
533.   
534.               // The text control needs to be active for the handle event function   
535.               // to succeed. See ITEXTCTL_SetActive usage for more information.   
536.               ITEXTCTL_SetActive (pMe->m_pIText, TRUE);   
537.   
538.               // ITEXTCTL_HandleEvent: is used to handle the events received by    
539.               // text control object. If the text control object is in non    
540.               // edit mode, it processed only set title, set text and press of    
541.               // UP and DOWN key events. In text edit mode, it processes various    
542.               // events like key up, key down, key held, set title, set text,    
543.               // command event from soft key menu.   
544.   
545.               // Invoke HandleEvent.    
546.               // This will move the cursor to the right by one character.   
547.               // By default the cursor is positioned at the begining of the   
548.               // text string. By invoking HandleEvents function with EVT_KEY event   
549.               // and the key value of AVK_RIGHT the cursor will be moved one    
550.               // character to the right on the display.   
551.               //   
552.               // Note: a more typical use of ITEXTCTL_HandleEvent is found in    
553.               // the HandleEvent function of this applet under EVT_KEY event.   
554.               if ((ITEXTCTL_HandleEvent(pMe->m_pIText, evt, wParam, dwParam)) == FALSE)   
555.               {   
556.                  // Do not need to return here. Fall through and invoke    
557.                  // DisplayEvents() function.   
558.               }   
559.   
560.               // The ITextCtl object is NOT released at this point. The ITextCtl    
561.               // object is released in the HandleEvents function under EVT_KEY.    
562.               // This gives the user the ability to edit text on an active    
563.               // ITextCtl object. The ITextCtl object is released when the user    
564.               // selects the Up/Down arrow to move to another main menu selection   
565.               // or when the user exits the applet.   
566.            }   
567.         }   
568.         break;   
569.      case USAGE_REDRAW:   
570.         {   
571.            // 3. Usage: ITEXTCTL_Redraw   
572.            ITextCtl * pITextCtl = NULL;   
573.            boolean boolRetVal = FALSE;   
574.            AECHAR    szBuf[50] = {0};    
575.            AEERect   rect;   
576.   
577.            // Create ITextCtl object. This step needs to be done only if   
578.            // the ITextCtl object has not been created already.    
579.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
580.   
581.            if (pITextCtl)   
582.            {   
583.               // Set Text/Rect for output display purposes only.    
584.               // See ITEXTCTL_SetRect/ITEXTCTL_SetText usage for more details.   
585.               SETAEERECT (&rect, 0, 2*pMe->m_nLineHeight, pMe->m_dInfo.cxScreen,    
586.                  pMe->m_dInfo.cyScreen*3/4);   
587.               ITEXTCTL_SetRect(pITextCtl, &rect);   
588.               STR_TO_WSTR("Redraw Text..", szBuf, sizeof(szBuf));   
589.               ITEXTCTL_SetText(pITextCtl, szBuf, sizeof (szBuf));   
590.   
591.               // ITEXTCTL_Redraw: instructs the text control object to redraw its    
592.               // contents. The text control object does not redraw its contents    
593.               // every time the underlying data behind the text control changes.    
594.               // This allows several data updates to occur while minimizing    
595.               // screen flashes. For example, several changes can be made to    
596.               // the contents of the text control object with no visible effect    
597.               // until Redraw method is called.   
598.   
599.               // Redraw text control object   
600.               if (!(boolRetVal = ITEXTCTL_Redraw (pITextCtl)))   
601.               {   
602.                  // Release Text control. This step only needs to be done   
603.                  // if no further use of the ITextCtl object is needed.   
604.                  ITEXTCTL_Release (pITextCtl);   
605.                  return;   
606.               }   
607.   
608.               // Release ITextCtl object. This step needs to be done   
609.               // only if no further use of the ITextCtl object is needed.   
610.               ITEXTCTL_Release (pITextCtl);   
611.            }   
612.         }   
613.         break;   
614.      case USAGE_SETACTIVE:   
615.         {   
616.            // 3. Usage: ITEXTCTL_SetActive    
617.            AECHAR    szBuf[50] = {0};    
618.   
619.            // Create ITextCtl object. This step needs to be done only if   
620.            // the ITextCtl object has not been created already.    
621.            //   
622.            // Create an instance of the ITextCtl object and store it in   
623.            // the CITextCtlApp class data member. This is used to better   
624.            // illustrate the ITextCtl object operations.   
625.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pMe->m_pIText);   
626.       
627.            if (pMe->m_pIText)   
628.            {      
629.               // Set Text/Rect for output display purposes.    
630.               // See ITEXTCTL_SetRect/ITEXTCTL_SetText usage for more details.   
631.               ITEXTCTL_SetRect(pMe->m_pIText, &rect);   
632.   
633.               // Draw the text control object with a border.   
634.               ITEXTCTL_SetProperties(pMe->m_pIText, TP_FRAME | TP_MULTILINE);   
635.               STR_TO_WSTR("SetActive Text..", szBuf, sizeof(szBuf));   
636.               ITEXTCTL_SetText(pMe->m_pIText, szBuf, sizeof (szBuf));   
637.   
638.               // ITEXTCTL_SetActive: is used to make a text control object    
639.               // active. Only an active text control object handles the event    
640.               // sent to it. Inactive text control object just ignores the events.   
641.   
642.               // Set text control object active.    
643.               ITEXTCTL_SetActive (pMe->m_pIText, TRUE);   
644.   
645.               // The ITextCtl object is NOT released at this time. The ITextCtl    
646.               // object is released in the HandleEvents function under EVT_KEY.    
647.               // This gives the user the ability to edit text on an active    
648.               // ITextCtl object. The ITextCtl object is released when the user    
649.               // selects the Up/Down arrow to move to another main menu selection   
650.               // or when the user exits the applet.   
651.            }   
652.         }   
653.         break;   
654.      case USAGE_ISACTIVE:   
655.         {   
656.            // 4. Usage: ITEXTCTL_IsActive   
657.            boolean   boolRetVal;   
658.            AECHAR    szBuf[50] = {0};    
659.           
660.            // Create ITextCtl object. This step needs to be done only if   
661.            // the ITextCtl object has not been created already.   
662.            //   
663.            // Create an instance of the ITextCtl object and store it in   
664.            // the CITextCtlApp class data member. This is used to better   
665.            // illustrate the ITextCtl interface operations.   
666.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pMe->m_pIText);   
667.   
668.            if (pMe->m_pIText)   
669.            {   
670.               // Set Text/Rect for output display purposes.    
671.               // See ITEXTCTL_SetRect/ITEXTCTL_SetText usage for more details.   
672.               ITEXTCTL_SetRect(pMe->m_pIText, &rect);   
673.               STR_TO_WSTR("IsActive Text..", szBuf, sizeof(szBuf));   
674.               ITEXTCTL_SetText(pMe->m_pIText, szBuf, sizeof (szBuf));   
675.               // First Set active   
676.               ITEXTCTL_SetActive (pMe->m_pIText, TRUE);   
677.   
678.               // Check if text control object is active. It should not be since   
679.               // text control is not activated.   
680.               if ((boolRetVal = ITEXTCTL_IsActive (pMe->m_pIText)) == FALSE)   
681.               {   
682.                  // Release ITextCtl object. This step needs to be done   
683.                  // only if no further use of the ITextCtl object is needed.   
684.                  ITEXTCTL_Release (pMe->m_pIText);   
685.                  pMe->m_pIText = NULL;   
686.                  return;   
687.               }   
688.   
689.               // The ITextCtl object is NOT released at this time. The ITextCtl    
690.               // object is released in the HandleEvents function under EVT_KEY.    
691.               // This gives the user the ability to edit text on an active    
692.               // ITextCtl object. The ITextCtl object is released when the user    
693.               // selects the Up/Down arrow to move to another menu selection.   
694.            }   
695.         }   
696.         break;   
697.      case USAGE_SETRECT:   
698.         {   
699.            // 5. Usage: ITEXTCTL_SetRect    
700.            ITextCtl * pITextCtl = NULL;   
701.            AEERect rct;   
702.            AECHAR    szBuf[50] = {0};    
703.   
704.            rct.x = pMe->m_dInfo.cxScreen/2;   
705.            rct.y = pMe->m_dInfo.cyScreen /2;   
706.            rct.dx = pMe->m_dInfo.cxScreen - 20;   
707.            rct.dy = pMe->m_dInfo.cyScreen/3;   
708.   
709.            // Create ITextCtl object. This step needs to be done only if   
710.            // the ITextCtl object has not been created already.    
711.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);    
712.   
713.            if (pITextCtl)   
714.            {   
715.               // ITEXTCTL_SetRect: sets the rectangle coordinates of area on the   
716.               // display where the text control object will be drawn.   
717.               ITEXTCTL_SetRect(pITextCtl, &rct);   
718.   
719.               // Set Text/Active for output display purposes.    
720.               // See ITEXTCTL_SetRect/ITEXTCTL_SetActive usage for more details.   
721.               STR_TO_WSTR("SetRect Text..", szBuf, sizeof(szBuf));   
722.               ITEXTCTL_SetText(pITextCtl, szBuf, sizeof (szBuf));   
723.   
724.               // Release ITextCtl object. This step needs to be done   
725.               // only if no further use of the ITextCtl object is needed.   
726.               ITEXTCTL_Release (pITextCtl);   
727.            }   
728.         }   
729.         break;   
730.      case USAGE_GETRECT:   
731.         {   
732.            // 6. Usage: ITEXTCTL_GetRect   
733.            ITextCtl *pITextCtl = NULL;   
734.            AEERect   rc = {0};   
735.    
736.            // Create ITextCtl object. This step needs to be done only if   
737.            // the ITextCtl object has not been created already.    
738.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
739.   
740.            if (pITextCtl)   
741.            {   
742.               // Get text control object rectangle   
743.               ITEXTCTL_GetRect(pITextCtl, &rc);   
744.   
745.               // No display output...   
746.   
747.               // Release ITextCtl object. This step needs to be done   
748.               // only if no further use of the ITextCtl object is needed.   
749.               ITEXTCTL_Release (pITextCtl);   
750.            }   
751.         }   
752.         break;         
753.      case USAGE_SETPROPERTIES:   
754.         {   
755.            // 7. Usage:ITEXTCTL_SetProperties   
756.            // Set the properties of the text control object so that   
757.            // there is a border drawn around the text control object,   
758.            // the text control object is multi-lined and enable T9 mode.   
759.            uint32     nProperties = TP_FRAME | TP_MULTILINE | TP_T9_MODE;   
760.            AECHAR    szBuf[50] = {0};    
761.       
762.            // Create ITextCtl object. This step needs to be done only if   
763.            // the ITextCtl object has not been created already.    
764.            //   
765.            // Create an instance of the ITextCtl object and store it in   
766.            // the CITextCtlApp class data member. This is used to better   
767.            // illustrate the ITextCtl interface operations.   
768.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pMe->m_pIText);   
769.   
770.            if (pMe->m_pIText)   
771.            {   
772.               // Set properties of text control object    
773.               ITEXTCTL_SetProperties(pMe->m_pIText,  nProperties);    
774.   
775.               // Set the y axis coordinate to new value, so that the   
776.               // control object rectangle is bigger.   
777.               rect.dy = pMe->m_dInfo.cyScreen/2;    
778.   
779.               ITEXTCTL_SetRect(pMe->m_pIText, &rect);   
780.               // Set Rect/Text/Active for output display purposes. For more details   
781.               // see ITEXTCTL_SetText/ITEXTCTL_SetRect/ITEXTCTL_SetActive usage.    
782.               STR_TO_WSTR("SetProperties Text..", szBuf, sizeof(szBuf));   
783.               ITEXTCTL_SetText(pMe->m_pIText, szBuf, sizeof (szBuf));   
784.               // Make the control object active so that the user can edit text.   
785.               ITEXTCTL_SetActive (pMe->m_pIText, TRUE);   
786.   
787.               // The ITextCtl object is NOT released at this time. The ITextCtl    
788.               // object is released in the HandleEvents function under EVT_KEY.    
789.               // This gives the user the ability to edit text on an active    
790.               // ITextCtl object. The ITextCtl object is released when the user    
791.               // selects the Up/Down arrow to move to another menu selection.   
792.            }   
793.         }   
794.         break;   
795.      case USAGE_GETPROPERTIES:   
796.         {   
797.            // 8. Usage: ITEXTCTL_GetProperties   
798.            ITextCtl * pITextCtl = NULL;   
799.            uint32     nProperties = 0;       // Test value   
800.   
801.              // Create ITextCtl object. This step needs to be done only if   
802.            // the ITextCtl object has not been created already.    
803.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
804.     
805.            if (pITextCtl)   
806.            {   
807.               // Get Properties   
808.               nProperties = ITEXTCTL_GetProperties(pITextCtl);       
809.   
810.               // No output...   
811.   
812.               // Release ITextCtl object. This step needs to be done   
813.               // only if no further use of the ITextCtl object is needed.   
814.               ITEXTCTL_Release (pITextCtl);   
815.            }   
816.         }   
817.         break;   
818.      case USAGE_RESET:   
819.         {   
820.            // 9. Usage: ITEXTCTL_Reset   
821.            AECHAR  szBuf[50] = {0};   
822.               
823.            // Create ITextCtl object. This step needs to be done only if   
824.            // the ITextCtl object has not been created already.    
825.             ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pMe->m_pIText);   
826.   
827.             if (pMe->m_pIText)   
828.            {   
829.               // Set Rect/Text/Active/Title for output display purposes only.    
830.               // For more details see ITEXTCTL_SetRect/ITEXTCTL_SetText/   
831.               // ITEXTCTL_SetActive/ITEXTCTL_SetTitle usage.    
832.               ITEXTCTL_SetRect(pMe->m_pIText, &rect);   
833.   
834.               // Set text to display.   
835.               STR_TO_WSTR("Reset Text..", szBuf, sizeof(szBuf));   
836.               ITEXTCTL_SetText(pMe->m_pIText, szBuf, sizeof (szBuf));   
837.   
838.               // This will make the text control object active.   
839.               ITEXTCTL_SetActive (pMe->m_pIText, TRUE);   
840.   
841.               // Set title of the text control object.   
842.               STR_TO_WSTR("TextCtl Title ", szBuf, sizeof(szBuf));   
843.               ITEXTCTL_SetTitle(pMe->m_pIText, NULL, NULL, szBuf);   
844.   
845.               // ITEXTCTL_Reset: instructs the text control to reset (free/delete)    
846.               // it's contents as well as to immediately leave active/focus mode.   
847.   
848.                 // Reset text control object. This should reset the title   
849.               // of the text control object and make the object inactive.   
850.                 ITEXTCTL_Reset (pMe->m_pIText);   
851.   
852.               // Redraw the text control object to see the effects of the   
853.               // Reset operation. The title set above will not be displayed   
854.               // since the reset released the title. Also the object is   
855.               // in the inactive mode (no arrow key inputs are handled by the   
856.               // text control).   
857.               ITEXTCTL_Redraw (pMe->m_pIText);   
858.   
859.               // The ITextCtl object is NOT released at this time. The ITextCtl    
860.               // object is released in the HandleEvents function under EVT_KEY.    
861.               // This gives the user the ability to edit text on an active    
862.               // ITextCtl object. The ITextCtl object is released when the user    
863.               // selects the Up/Down arrow to move to another menu selection.   
864.            }   
865.         }   
866.         break;   
867.      case USAGE_SETTITLE_LOCAL:   
868.         {   
869.            // 10. Usage: ITEXTCTL_SetTitle   
870.            ITextCtl * pITextCtl = NULL;   
871.            boolean    boolRetVal = FALSE;   
872.            AECHAR szBuf [50];   
873.                
874.            // Create ITextCtl object. This step needs to be done only if   
875.            // the ITextCtl object has not been created already.    
876.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
877.   
878.            if (pITextCtl)   
879.            {          
880.               ITEXTCTL_SetRect(pITextCtl, &rect);   
881.               ITEXTCTL_SetProperties(pITextCtl,  TP_FRAME);   
882.   
883.               // Set title using locally defined strings.   
884.               STR_TO_WSTR("TextCtl Title ", szBuf, sizeof(szBuf));   
885.               if (!(boolRetVal = ITEXTCTL_SetTitle(pITextCtl, NULL, NULL, szBuf)))   
886.               {   
887.                  // Release Date control. This step only needs to be done   
888.                  // if no further use of the ITextCtl object is needed.   
889.                  ITEXTCTL_Release (pITextCtl);   
890.                  return;   
891.               }   
892.   
893.               // Initialize some text for display.   
894.               STR_TO_WSTR("SetTitle Text..", szBuf, sizeof(szBuf));   
895.               ITEXTCTL_SetText(pITextCtl, szBuf, sizeof (szBuf));   
896.   
897.               // Release ITextCtl object. This step needs to be done   
898.               // only if no further use of the ITextCtl object is needed.   
899.               ITEXTCTL_Release (pITextCtl);   
900.            }   
901.         }   
902.         break;   
903.      case USAGE_SETTITLE_RES:   
904.         {   
905.            // 10. Usage: ITEXTCTL_SetTitle   
906.            ITextCtl * pITextCtl = NULL;   
907.            boolean    boolRetVal = FALSE;   
908.            char szResFile[] = APP_RES_FILE;   // Resource File used by this applet   
909.            AECHAR szBuf [50];   
910.                
911.            // Create ITextCtl object. This step needs to be done only if   
912.            // the ITextCtl object has not been created already.    
913.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
914.   
915.            if (pITextCtl)   
916.            {          
917.               ITEXTCTL_SetRect(pITextCtl, &rect);   
918.               ITEXTCTL_SetProperties(pITextCtl,  TP_FRAME);   
919.   
920.               // Set title using string defined in resource file.   
921.               if (!(boolRetVal = ITEXTCTL_SetTitle(pITextCtl, szResFile, IDS_TITLE, NULL)))   
922.               {   
923.                  // Release Date control. This step only needs to be done   
924.                  // if no further use of the ITextCtl object is needed.   
925.                  ITEXTCTL_Release (pITextCtl);   
926.                  return;   
927.               }   
928.   
929.               // Initialize some text as well for display.   
930.               STR_TO_WSTR("SetTitle Text..", szBuf, sizeof(szBuf));   
931.               ITEXTCTL_SetText(pITextCtl, szBuf, sizeof (szBuf));   
932.   
933.               // Release ITextCtl object. This step needs to be done   
934.               // only if no further use of the ITextCtl object is needed.   
935.               ITEXTCTL_Release (pITextCtl);   
936.            }   
937.         }   
938.         break;   
939.      case USAGE_SETTEXT:   
940.         {   
941.            // 11. Usage: ITEXTCTL_SetText   
942.            ITextCtl * pITextCtl = NULL;   
943.            boolean    boolRetVal = FALSE;   
944.            AECHAR szBuf [50];   
945.                
946.            // Create ITextCtl object. This step needs to be done only if   
947.            // the ITextCtl object has not been created already.    
948.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
949.   
950.            if (pITextCtl)   
951.            {      
952.               // Set rectangle   
953.               ITEXTCTL_SetRect(pITextCtl, &rect);   
954.   
955.               // Set title   
956.               STR_TO_WSTR("Text Control Text..", szBuf, sizeof(szBuf));   
957.               if ((boolRetVal = ITEXTCTL_SetText(pITextCtl, szBuf, sizeof (szBuf)))   
958.                  == FALSE)   
959.               {   
960.                  // Release Date control. This step only needs to be done   
961.                  // if no further use of the ITextCtl object is needed.   
962.                  ITEXTCTL_Release (pITextCtl);   
963.                  return;   
964.               }   
965.   
966.               // Release ITextCtl object. This step needs to be done   
967.               // only if no further use of the ITextCtl object is needed.   
968.               ITEXTCTL_Release (pITextCtl);   
969.            }   
970.         }   
971.         break;   
972.      case USAGE_GETTEXT:   
973.         {   
974.            // 12. Usage: ITEXTCTL_GetText   
975.            ITextCtl * pITextCtl = NULL;   
976.            boolean    bRetVal = FALSE;   
977.            char pszStr[30] = {0};   
978.            AECHAR szBuf1[30] = {0};   
979.            AECHAR szBuf2[30] = {0};   
980.   
981.            // Create ITextCtl object. This step needs to be done only if   
982.            // the ITextCtl object has not been created already.    
983.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
984.   
985.            if (pITextCtl)   
986.            {          
987.               // Set rectangle to point to the a section of the top half    
988.               // of the screen. Also, have a frame around the text by   
989.               // setting the properties and setting the control object active.   
990.               rect.y = pMe->m_nLineHeight * 2;   
991.               ITEXTCTL_SetRect(pITextCtl, &rect);   
992.               ITEXTCTL_SetProperties(pITextCtl,  TP_FRAME);   
993.               ITEXTCTL_SetActive (pITextCtl, TRUE);   
994.   
995.               // Set text so that the text control object will have some   
996.               // valid text when we retrieve text from it. Also, by   
997.               // setting the properties and activating the text control   
998.               // object it srounds the text control object text with    
999.               // a frame. This is done to distinguish it from the text   
1000.               // retrieved from the text control object (using ITEXTCTL_GetText   
1001.               // below) and printed to screen.   
1002.               STR_TO_WSTR("GetTextPtr Text..", szBuf1, sizeof(szBuf1));   
1003.               ITEXTCTL_SetText(pITextCtl, szBuf1, sizeof (szBuf1));   
1004.   
1005.               // ITEXTCTL_GetText: is used to read text associated with the    
1006.               // text control object in the given buffer subject to the maximum    
1007.               // of specified characters.   
1008.               if ((bRetVal = ITEXTCTL_GetText (pITextCtl, szBuf2, sizeof (szBuf2)))   
1009.                  == TRUE)   
1010.               {   
1011.                  // Convert the wide-string to char. This is done only to    
1012.                  // use a single display function.   
1013.                  WSTR_TO_STR (szBuf2, pszStr, sizeof (pszStr));   
1014.   
1015.                  // Display the text retrieved. In the middle of the    
1016.                  // screen. This text will not have a frame srounding it.   
1017.                  DisplayOutput (pMe, -1, pszStr);   
1018.               }   
1019.               else    
1020.               {   
1021.                  DisplayOutput (pMe, -1, "GetText: Failed..");   
1022.               }   
1023.   
1024.               // Release ITextCtl object. This step needs to be done   
1025.               // only if no further use of the ITextCtl object is needed.   
1026.               ITEXTCTL_Release (pITextCtl);   
1027.            }   
1028.         }   
1029.         break;         
1030.      case USAGE_GETTEXTPTR:   
1031.         {   
1032.            // 13. Usage: ITEXTCTL_GetTextPtr   
1033.            ITextCtl * pITextCtl = NULL;   
1034.            char pszStr[30] = {0};   
1035.            AECHAR * pszText = NULL;   
1036.            AECHAR szBuf [30] = {0};   
1037.   
1038.            // Create ITextCtl object. This step needs to be done only if   
1039.            // the ITextCtl object has not been created already.    
1040.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
1041.   
1042.            if (pITextCtl)   
1043.            {   
1044.               // Set rectangle to point to the a section of the top half    
1045.               // of the screen. Also, have a frame around the text by   
1046.               // setting the properties and setting the control object active.   
1047.               // Set rectangle   
1048.               // Set rectangle to point to the a section of the top half    
1049.               // of the screen. Also, have a frame around the text by   
1050.               // setting the properties and setting the control object active.   
1051.               rect.y = pMe->m_nLineHeight * 2;   
1052.               ITEXTCTL_SetRect(pITextCtl, &rect);   
1053.               ITEXTCTL_SetProperties(pITextCtl,  TP_FRAME);   
1054.               ITEXTCTL_SetActive (pITextCtl, TRUE);   
1055.   
1056.               // Set text so that the text control object will have some   
1057.               // valid text when we retrieve a pointer to it. Also, by   
1058.               // setting the properties and activating the text control   
1059.               // object it srounds the text control object text with    
1060.               // a frame. This is done to distinguish it from the text   
1061.               // retrieved from the text control object (using    
1062.               // ITEXTCTL_GetTextPtr below) and printed to screen.   
1063.               STR_TO_WSTR("GetTextPtr Text..", szBuf, sizeof(szBuf));   
1064.               ITEXTCTL_SetText(pITextCtl, szBuf, sizeof (szBuf));   
1065.   
1066.               // ITEXTCTL_GetText: is used to read text associated with the    
1067.               // text control object in the given buffer subject to the maximum    
1068.               // of specified characters.   
1069.               if ((pszText = ITEXTCTL_GetTextPtr (pITextCtl))   
1070.                  != NULL)   
1071.               {   
1072.                  // Convert the wide-string to char. This is done only to    
1073.                  // use a single display function.   
1074.                  WSTR_TO_STR (pszText, pszStr, sizeof (pszStr));   
1075.   
1076.                  // Display text retrieved from the text control object.   
1077.                  DisplayOutput (pMe, -1, pszStr);   
1078.               }   
1079.   
1080.               // Release ITextCtl object. This step needs to be done   
1081.               // only if no further use of the ITextCtl object is needed.   
1082.               ITEXTCTL_Release (pITextCtl);   
1083.            }   
1084.         }   
1085.         break;   
1086.      case USAGE_ENABLECOMMAND:   
1087.         {   
1088.            // 14. Usage: ITEXTCTL_EnableCommand   
1089.            ITextCtl * pITextCtl = NULL;   
1090.            uint16 nCmdId = EVT_KEY_PRESS;   
1091.   
1092.            // Create ITextCtl object. This step needs to be done only if   
1093.            // the ITextCtl object has not been created already.    
1094.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
1095.   
1096.            if (pITextCtl)   
1097.            {   
1098.               // ITEXTCTL_EnableCommand: is used to enable sending of specified    
1099.               // command by the text control object to the shell object upon    
1100.               // receiving the event generated by pressing center key.   
1101.               ITEXTCTL_EnableCommand (pITextCtl, TRUE, nCmdId);   
1102.   
1103.               // No output for this function...   
1104.   
1105.               // Release ITextCtl object. This step needs to be done   
1106.               // only if no further use of the ITextCtl object is needed.   
1107.               ITEXTCTL_Release (pITextCtl);   
1108.            }   
1109.         }   
1110.         break;   
1111.      case USAGE_SETMAXSIZE:   
1112.         {   
1113.            // 15. Usage: ITEXTCTL_SetMaxSize   
1114.            ITextCtl * pITextCtl = NULL;   
1115.            uint16 nMaxSize = 100;   
1116.   
1117.            // Create ITextCtl object. This step needs to be done only if   
1118.            // the ITextCtl object has not been created already.    
1119.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pITextCtl);   
1120.   
1121.            if (pITextCtl)   
1122.            {   
1123.               // ITEXTCTL_SetMaxSize: is used to set maximum text size supported    
1124.               // by the text control object. If the size being set is more than    
1125.               // the size already set, this leads to the freeing up of the    
1126.               // memory associated with the previous size and allocation of the    
1127.               // memory as per new size.   
1128.               ITEXTCTL_SetMaxSize (pITextCtl, nMaxSize);   
1129.   
1130.               // No output for this function...   
1131.   
1132.               // Release ITextCtl object. This step needs to be done   
1133.               // only if no further use of the ITextCtl object is needed.   
1134.               ITEXTCTL_Release (pITextCtl);   
1135.            }   
1136.         }   
1137.         break;         
1138.      case USAGE_SETSOFTKEYMENU:   
1139.         {   
1140.            // 16. Usage: ITEXTCTL_SetSoftKeyMenu   
1141.            AECHAR szBuf[50] = {0};   
1142.            AEERect softKeyRect;   
1143.   
1144.            // Create ITextCtl object. This step needs to be done only if   
1145.            // the ITextCtl object has not been created already.    
1146.            ISHELL_CreateInstance(pIShell, AEECLSID_TEXTCTL, (void **)&pMe->m_pIText);   
1147.   
1148.            if (pMe->m_pIText)   
1149.            {   
1150.               // Create IMenuCtl object. This step needs to be done only if   
1151.               // the IMenuCtl object has not been created already.    
1152.               ISHELL_CreateInstance(pMe->a.m_pIShell, AEECLSID_SOFTKEYCTL, (void **)&pMe->m_pISoftKey);   
1153.   
1154.               if (!pMe->m_pISoftKey)   
1155.               {   
1156.                  ITEXTCTL_Release (pMe->m_pIText);   
1157.                  pMe->m_pIText = NULL;   
1158.                  return;   
1159.               }   
1160.   
1161.               // Set the soft key menu rectangle coordinates.   
1162.               softKeyRect.x = 0;   
1163.               softKeyRect.y = pMe->m_dInfo.cyScreen - (pMe->m_nLineHeight * 4);   
1164.               softKeyRect.dx = pMe->m_dInfo.cxScreen;   
1165.               softKeyRect.dy = pMe->m_nLineHeight * 2;   
1166.               // Set Rectangle   
1167.               IMENUCTL_SetRect(pMe->m_pISoftKey, &softKeyRect);   
1168.   
1169.               // Set title of the text control object   
1170.               STR_TO_WSTR("TextCtl Title ", szBuf, sizeof(szBuf));   
1171.               ITEXTCTL_SetTitle(pMe->m_pIText, NULL, NULL, szBuf);   
1172.   
1173.               // Set the max size of the text supported by the text control object.   
1174.               ITEXTCTL_SetMaxSize(pMe->m_pIText, 100);   
1175.   
1176.               // Set properties of the text control object to have a frame and    
1177.               // to have a multi-lined text edit capability.   
1178.               ITEXTCTL_SetProperties(pMe->m_pIText, TP_FRAME | TP_MULTILINE );   
1179.   
1180.               // Specify the area where the text control object is to be placed.   
1181.               rect.y = pMe->m_nLineHeight * 2;   
1182.               rect.dy = pMe->m_dInfo.cyScreen/2;   
1183.               ITEXTCTL_SetRect(pMe->m_pIText, &rect);   
1184.   
1185.   
1186.               // Initialize the softkey menu of the text control.   
1187.               ITEXTCTL_SetSoftKeyMenu (pMe->m_pIText, pMe->m_pISoftKey);                   
1188.   
1189.               // Initialize the text field of the text control object.   
1190.               STR_TO_WSTR("SoftKey menu Text..", szBuf, sizeof(szBuf));   
1191.               ITEXTCTL_SetText(pMe->m_pIText, szBuf, sizeof (szBuf));   
1192.   
1193.               // Set both the soft key and text control active.   
1194.               IMENUCTL_SetActive(pMe->m_pISoftKey,TRUE);   
1195.               ITEXTCTL_SetActive (pMe->m_pIText, TRUE);   
1196.   
1197.               // The ITextCtl object is NOT released at this time. The ITextCtl    
1198.               // object is released in the HandleEvents function under EVT_KEY.    
1199.               // This gives the user the ability to edit text on an active    
1200.               // ITextCtl object. The ITextCtl object is released when the user    
1201.               // selects the Up/Down arrow to move to another menu selection.   
1202.            }   
1203.         }   
1204.         break;   
1205.      default:   
1206.         return;   
1207.   }   
1208.      
1209.   // Display above event.    
1210.   DisplayEvent (pMe, wParam);   
1211.   
1212.   return;   
1213.}   
1214.   
1215./*===========================================================================  
1216.  
1217.FUNCTION: DisplayEvent  
1218.  
1219.DESCRIPTION  
1220.    This function is a display function which sets up the initial screen  
1221.    for the display output for a given interface function. This displays  
1222.    the function name at the top of the screen and displays the  
1223.    strings "Press Up/Down" and "keys to continue.." at the bottom of   
1224.    the screen. In the case of functions that have no output it also   
1225.    displays the string "No Output..." in the middile of the screen.  
1226.  
1227.PROTOTYPE:  
1228.   void DisplayEvent (CITextCtlApp *pMe, uint16 wParam)  
1229.  
1230.PARAMETERS:  
1231.   pMe:    [in]: Pointer to CITextCtlApp interface object  
1232.   wParam: [in]: API function type Id selected by user  
1233.  
1234.DEPENDENCIES  
1235.  None  
1236.  
1237.RETURN VALUE  
1238.  None  
1239.  
1240.SIDE EFFECTS  
1241.  None  
1242.  
1243.===========================================================================*/   
1244.static void DisplayEvent (CITextCtlApp *pMe, uint16 wParam)   
1245.{   
1246.   AECHAR szBuf[100];   
1247.   AEERect rc;    
1248.   
1249.   if (pMe == NULL || pMe->a.m_pIShell == NULL || pMe->a.m_pIDisplay == NULL)   
1250.      return;   
1251.   
1252.   // Set display rectangle   
1253.   SETAEERECT (&rc, 0, 0, pMe->m_dInfo.cxScreen, pMe->m_dInfo.cyScreen);   
1254.   
1255.   if (pMe->a.m_pIDisplay)   
1256.   {   
1257.      switch (wParam)   
1258.      {   
1259.         case USAGE_BASIC_USAGE:   
1260.            STR_TO_WSTR("Basic Usage:", szBuf, sizeof(szBuf));   
1261.            break;   
1262.         case USAGE_HANDLEEVENT:   
1263.            STR_TO_WSTR("HandleEvent", szBuf, sizeof(szBuf));   
1264.            break;   
1265.         case USAGE_REDRAW:   
1266.            STR_TO_WSTR("Redraw", szBuf, sizeof(szBuf));   
1267.            break;   
1268.         case USAGE_SETACTIVE:   
1269.            STR_TO_WSTR("SetActive", szBuf, sizeof(szBuf));   
1270.            break;   
1271.         case USAGE_ISACTIVE:   
1272.            STR_TO_WSTR("IsActive", szBuf, sizeof(szBuf));   
1273.            break;   
1274.         case USAGE_SETRECT:   
1275.            STR_TO_WSTR("SetRect", szBuf, sizeof(szBuf));   
1276.            break;   
1277.         case USAGE_GETRECT:   
1278.            STR_TO_WSTR("GetRect", szBuf, sizeof(szBuf));   
1279.            break;   
1280.         case USAGE_SETPROPERTIES:   
1281.            STR_TO_WSTR("SetProperties", szBuf, sizeof(szBuf));   
1282.            break;   
1283.         case USAGE_GETPROPERTIES:   
1284.            STR_TO_WSTR("GetProperties", szBuf, sizeof(szBuf));   
1285.            break;   
1286.         case USAGE_RESET:   
1287.            STR_TO_WSTR("Reset", szBuf, sizeof(szBuf));   
1288.            break;   
1289.         case USAGE_SETTITLE_LOCAL:   
1290.            STR_TO_WSTR("SetTitle (Local)", szBuf, sizeof(szBuf));   
1291.            break;   
1292.         case USAGE_SETTITLE_RES:   
1293.            STR_TO_WSTR("SetTitle (Resource)", szBuf, sizeof(szBuf));   
1294.            break;   
1295.         case USAGE_SETTEXT:   
1296.            STR_TO_WSTR("SetText", szBuf, sizeof(szBuf));   
1297.            break;   
1298.         case USAGE_GETTEXT:   
1299.            STR_TO_WSTR("GetText", szBuf, sizeof(szBuf));   
1300.            break;   
1301.         case USAGE_GETTEXTPTR:   
1302.            STR_TO_WSTR("GetTextPtr", szBuf, sizeof(szBuf));   
1303.            break;   
1304.         case USAGE_ENABLECOMMAND:   
1305.            STR_TO_WSTR("EnableCommand", szBuf, sizeof(szBuf));   
1306.            break;   
1307.         case USAGE_SETMAXSIZE:   
1308.            STR_TO_WSTR("SetMaxSize", szBuf, sizeof(szBuf));   
1309.            break;   
1310.         case USAGE_SETSOFTKEYMENU:   
1311.            STR_TO_WSTR("SetSoftKeyMenu", szBuf, sizeof(szBuf));   
1312.            break;   
1313.         default:   
1314.            STR_TO_WSTR("Unsupported fn", szBuf, sizeof(szBuf));   
1315.      }   
1316.        IDISPLAY_DrawText(pMe->a.m_pIDisplay, AEE_FONT_NORMAL, szBuf, -1,5, 5, &rc,   
1317.           IDF_ALIGN_NONE|  IDF_TEXT_TRANSPARENT);   
1318.   
1319.      // Functions with no output   
1320.      switch (wParam)   
1321.      {   
1322.         case USAGE_GETRECT:   
1323.         case USAGE_GETPROPERTIES:   
1324.         case USAGE_ENABLECOMMAND:   
1325.         case USAGE_SETMAXSIZE:   
1326.            // Place in the middle of screen   
1327.            STR_TO_WSTR("No Output...", szBuf, sizeof(szBuf));   
1328.              IDISPLAY_DrawText(pMe->a.m_pIDisplay, AEE_FONT_NORMAL, szBuf, -1,10,    
1329.               rc.dy/2 - pMe->m_nLineHeight, &rc, IDF_ALIGN_NONE|  IDF_TEXT_TRANSPARENT);   
1330.         default:   
1331.            break;   
1332.      }   
1333.   
1334.      STR_TO_WSTR("UP/DOWN to continue..", szBuf, sizeof(szBuf));   
1335.        IDISPLAY_DrawText(pMe->a.m_pIDisplay, AEE_FONT_NORMAL, szBuf, -1,5, rc.dy -    
1336.         pMe->m_nLineHeight, &rc, IDF_ALIGN_NONE | IDF_TEXT_TRANSPARENT);   
1337.        IDISPLAY_UpdateEx(pMe->a.m_pIDisplay,TRUE);   
1338.   }   
1339.}   
1340.   
1341./*===========================================================================  
1342.  
1343.FUNCTION: BuildMainMenu  
1344.  
1345.DESCRIPTION  
1346.    This function builds the main menu when this applet is started.  
1347.    It displays a simple menu with menu items corresponding to   
1348.    each of the interface functions.  
1349.      
1350.PROTOTYPE:  
1351.   void BuildMainMenu(CITextCtlApp *pMe)  
1352.  
1353.PARAMETERS:  
1354.   pMe: [in]: Pointer to AEEApplet struct  
1355.  
1356.DEPENDENCIES  
1357.  None  
1358.  
1359.RETURN VALUE  
1360.  None  
1361.  
1362.SIDE EFFECTS  
1363.  None  
1364.  
1365.===========================================================================*/   
1366.static void BuildMainMenu(CITextCtlApp *pMe)   
1367.{   
1368.    AEERect rc;   
1369.   AECHAR szBuf[100];   
1370.   
1371.   if (pMe->m_pIMenu == NULL || pMe->a.m_pIShell == NULL)   
1372.      return;   
1373.   
1374.   // Set display rectangle   
1375.   SETAEERECT (&rc, 0, 0, pMe->m_dInfo.cxScreen, pMe->m_dInfo.cyScreen);   
1376.   
1377.    // Set Title   
1378.   STR_TO_WSTR("ITextCtl Examples", szBuf, sizeof(szBuf));   
1379.    IMENUCTL_SetTitle(pMe->m_pIMenu, NULL, 0, szBuf);   
1380.   
1381.    IMENUCTL_SetRect(pMe->m_pIMenu, &rc);     
1382.   
1383.    //Add invidual entries to the Menu   
1384.   
1385.   // Add Basic Usage to menu   
1386.   STR_TO_WSTR("1. Basic Usage", szBuf, sizeof(szBuf));   
1387.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_BASIC_USAGE, szBuf, 0);   
1388.   
1389.   // Add Handle Event to menu   
1390.   STR_TO_WSTR("2. HandleEvent", szBuf, sizeof(szBuf));   
1391.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_HANDLEEVENT, szBuf, 0);   
1392.   
1393.   // Add Redraw to menu   
1394.   STR_TO_WSTR("3. Redraw", szBuf, sizeof(szBuf));   
1395.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_REDRAW, szBuf, 0);   
1396.               
1397.   // Add SetActive to menu   
1398.   STR_TO_WSTR("4. SetActive", szBuf, sizeof(szBuf));   
1399.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_SETACTIVE, szBuf, 0);   
1400.   
1401.   // Add IsActive to menu   
1402.   STR_TO_WSTR("5. IsActive", szBuf, sizeof(szBuf));   
1403.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_ISACTIVE, szBuf, 0);   
1404.   
1405.    // Add SetRect to menu   
1406.   STR_TO_WSTR("6. SetRect", szBuf, sizeof(szBuf));   
1407.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_SETRECT, szBuf, 0);   
1408.   
1409.    // Add GetRect to menu   
1410.   STR_TO_WSTR("7. GetRect", szBuf, sizeof(szBuf));   
1411.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_GETRECT, szBuf, 0);     
1412.   
1413.    // Add Set Properties to menu   
1414.   STR_TO_WSTR("8. SetProperties", szBuf, sizeof(szBuf));   
1415.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_SETPROPERTIES, szBuf, 0);       
1416.   
1417.    // Add GetProperties to menu   
1418.   STR_TO_WSTR("9. GetProperties", szBuf, sizeof(szBuf));   
1419.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_GETPROPERTIES, szBuf, 0);       
1420.   
1421.    // Add Reset to menu   
1422.   STR_TO_WSTR("10. Reset", szBuf, sizeof(szBuf));   
1423.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_RESET, szBuf, 0);       
1424.   
1425.   // Add SetTitle to menu   
1426.   STR_TO_WSTR("11. SetTitle (Local)", szBuf, sizeof(szBuf));   
1427.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_SETTITLE_LOCAL, szBuf, 0);      
1428.   
1429.   // Add SetTitle to menu   
1430.   STR_TO_WSTR("12. SetTitle (Resource)", szBuf, sizeof(szBuf));   
1431.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_SETTITLE_RES, szBuf, 0);    
1432.   
1433.   // Add SetText to menu   
1434.   STR_TO_WSTR("13. SetText", szBuf, sizeof(szBuf));   
1435.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_SETTEXT, szBuf, 0);     
1436.   
1437.   // Add GetText to menu   
1438.   STR_TO_WSTR("14. GetText", szBuf, sizeof(szBuf));   
1439.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_GETTEXT, szBuf, 0);     
1440.   
1441.    // Add SetTextPtr to menu   
1442.   STR_TO_WSTR("15. GetTextPtr", szBuf, sizeof(szBuf));   
1443.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_GETTEXTPTR, szBuf, 0);      
1444.   
1445.    // Add EnableCommand to menu   
1446.   STR_TO_WSTR("16. EnableCommand", szBuf, sizeof(szBuf));   
1447.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_ENABLECOMMAND, szBuf, 0);       
1448.   
1449.    // Add SetMaxSize to menu   
1450.   STR_TO_WSTR("17. SetMaxSize", szBuf, sizeof(szBuf));   
1451.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_SETMAXSIZE, szBuf, 0);      
1452.   
1453.    // Add SetSoftKeyMenu to menu   
1454.   STR_TO_WSTR("18. SetSoftKeyMenu", szBuf, sizeof(szBuf));   
1455.    IMENUCTL_AddItem(pMe->m_pIMenu, 0, 0, USAGE_SETSOFTKEYMENU, szBuf, 0);      
1456.   
1457.   // Activate menu   
1458.    IMENUCTL_SetActive(pMe->m_pIMenu,TRUE);   
1459.}   
1460.   
1461./*===========================================================================  
1462.  
1463.FUNCTION: DisplayOutput  
1464.  
1465.DESCRIPTION  
1466.    This function displays an output string at a given line number on the  
1467.    screen. If the nline parameter is a negative value (-1) the string  
1468.    is displayed in the middle of the screen. If the "nline" value is larger  
1469.    than or equal to zero the "nline" value is multiplied by 15 and the   
1470.    resulting value in pixels is set to the y-coordinate of the start of   
1471.    the string display on the screen. If the string does not fit on one line  
1472.    the string wraps around to the next line (spaced rougly 10-15 pixels apart).  
1473.    By default 5 is used as the starting the x-coordinate of a displayed   
1474.    string.  
1475.  
1476.    How many characters that fit on one line is calculated for each line   
1477.    that is wrapped around to the next line.  
1478.  
1479.    Note: depending on the phone screen size and the fonts used for characters   
1480.          the output might differ on different handsets (devices). Where some   
1481.          handsets will have a smaller screen and large default fonts which will   
1482.          cause partial overlapping of lines. This function does not try to address  
1483.          these issues (this is meant as a simple display function).  
1484.      
1485.PROTOTYPE:  
1486.   void DisplayOutput(CITextCtlApp * pi, int nline, char *pszStr)  
1487.  
1488.PARAMETERS:  
1489.   pi:     [in]: Contains a pointer to the CITextCtlApp class.  
1490.   nline:  [in]: Contains the line number to start displaying the text.   
1491.        The line numbers are by default spaced 15 pixels apart along the y-axis.  
1492.   pszStr: [in]: The character string to be displayed on the screen.  
1493.  
1494.DEPENDENCIES  
1495.  None  
1496.  
1497.RETURN VALUE  
1498.  None  
1499.  
1500.SIDE EFFECTS  
1501.  None  
1502.  
1503.===========================================================================*/   
1504.static void DisplayOutput(CITextCtlApp * pMe, int nline, char *pszStr)   
1505.{   
1506.   AECHAR * pszBuf = NULL;   
1507.   AECHAR * psz = NULL;   
1508.   int pixelWidth;   
1509.   AEEFont font = AEE_FONT_NORMAL;   
1510.   int pnFits = 0, dy;   
1511.   int totalCh = 0;   
1512.   
1513.   if (pMe == NULL)   
1514.      return;   
1515.   
1516.   // Allocate buffer to hold string.   
1517.   if ((pszBuf = (AECHAR *)MALLOC(200)) == NULL)   
1518.      return;   
1519.   
1520.   // Convert to wide string (unicode)   
1521.   STR_TO_WSTR ((char *)pszStr, pszBuf, 200);   
1522.   
1523.   // If nlines is zero then print this string starting around the middle of    
1524.   // the screen. Or else multiply nlines by 10 to decide the y coordinate of   
1525.   // the start of the string.   
1526.   if (nline < 0) {   
1527.      dy = pMe->m_dInfo.cyScreen*2/5;   
1528.   }   
1529.   else{   
1530.      dy = nline * pMe->m_nLineHeight;   
1531.   }   
1532.   
1533.   // psz keeps track of the point from which to write from the string buffer   
1534.   // in case the string does not fit one line and needs to wrap around in the   
1535.   // next line.   
1536.   psz = pszBuf;   
1537.         
1538.   // Need to calculate the lotal string length to decide if any wrapping   
1539.   // around is needed.   
1540.   totalCh = STRLEN ((char *)pszStr);   
1541.   
1542.   // Keep displaying text string on multiple lines if the string can't be displayed   
1543.   // on one single line. Lines are spaced 15 pixels apart.   
1544.   while ((totalCh > 0) && (*psz != NULL))   
1545.   {    
1546.      // Get information on how many characters will fit in a line.   
1547.      // Give the pointer to the buffer to be displayed, and the number of   
1548.      // pixels along the x axis you want to display the string in (max number)   
1549.      // pnFits will have the max number of chars that will fit in the maxWidth   
1550.      // number of pixels (given string can't fit in one line), or the number of    
1551.      // chars in the string (if it does fit in one line). pnWidth gives the   
1552.      // number of pixels that will be used to display pnFits number of chars.   
1553.      pixelWidth = IDISPLAY_MeasureTextEx(pMe->a.m_pIDisplay,   
1554.                      font,    
1555.                      (AECHAR *) psz,  // Start of the buffer to display,   
1556.                      -1,   
1557.                      pMe->m_dInfo.cxScreen - 5, // maxWidth   
1558.                      &pnFits);         // Number of chars that will fit a line   
1559.   
1560.      // If pnFits is zero there is something wrong in the input to above function.    
1561.      // Normally this scenario should not occur. But, have the check anyway.   
1562.      if (pnFits == 0)   
1563.      {   
1564.         FREE (pszBuf);   
1565.         return;   
1566.      }   
1567.   
1568.      IDISPLAY_DrawText(pMe->a.m_pIDisplay, AEE_FONT_NORMAL, psz, pnFits, 5 /*start dx*/,    
1569.         dy, 0 /* use default rectangle coordinates */, 0);   
1570.   
1571.      psz += pnFits;      // move pointer to the next segment to be displayed   
1572.      totalCh -= pnFits;  // reduce the total number of characters to still display   
1573.      dy += pMe->m_nLineHeight; // Place next line charHeight pixels below the    
1574.                                // previous line.    
1575.      IDISPLAY_Update(pMe->a.m_pIDisplay);   
1576.      if (totalCh < pnFits)   
1577.         pnFits = totalCh;  // if total number is less than pnFits, adjust pnFits   
1578.   }   
1579.   
1580.   FREE (pszBuf);   
1581.   return;      
1582.} // End of DisplayOutput 
