/*===========================================================================

FILE: mytext.c
===========================================================================*/


/*===============================================================================
INCLUDES AND VARIABLE DEFINITIONS
=============================================================================== */
#include "AEEModGen.h"          // Module interface definitions
#include "AEEAppGen.h"          // Applet interface definitions
#include "AEEShell.h"           // Shell interface definitions
#include "AEEMenu.h"
#include "AEEText.h"
#include "AEEStdLib.h"

#include "mytext.bid"
#include "mytext_res.h"

#define ID_SINGLE         1
#define ID_MULTI          2

#define ID_DISPLAY        3
#define ID_OK             4
#define ID_INPUTMODE      5

#define STATUS_MENU       6
#define STATUS_SINGLE     7
#define STATUS_MULTI      8
#define STATUS_INPUTMENU  9
 
#define FOCUS_TEXT1       10
#define FOCUS_TEXT2       11

/*-------------------------------------------------------------------
Applet structure. All variables in here are reference via "pMe->"
-------------------------------------------------------------------*/
typedef struct _mytext {
	AEEApplet      a ;	       // First element of this structure must be AEEApplet
    AEEDeviceInfo  DeviceInfo; // always have access to the hardware device information
    IDisplay      *pIDisplay;  // give a standard way to access the Display interface
    IShell        *pIShell;    // give a standard way to access the Shell interface

    // add your own variables here...
	IMenuCtl      *pMenu;
	ITextCtl      *pSingleText;
	IMenuCtl      *pSoftkey1;

	ITextCtl      *pMultiText1;
	AECHAR        *pContent1;
	ITextCtl      *pMultiText2;
	AECHAR        *pContent2;
	IMenuCtl      *pSoftkey2;
	IMenuCtl      *pInputMenu;
	uint16         textctl_focus;
	uint16         input_mode;
	uint16         input_flag;
	int            status;
} mytext;

/*-------------------------------------------------------------------
Function Prototypes
-------------------------------------------------------------------*/
static  boolean mytext_HandleEvent(mytext* pMe, AEEEvent eCode, 
                                             uint16 wParam, uint32 dwParam);
boolean mytext_InitAppData(mytext* pMe);
void    mytext_FreeAppData(mytext* pMe);
static void BuildMainMenu(mytext *pMe);
static void DisplaySingleText(mytext *pMe);
static void DisplayMultiText(mytext *pMe);
static void BuildInputMenu(mytext *pMe);
static void GetContent(mytext *pMe);
static void SetContent(mytext *pMe);
/*===============================================================================
FUNCTION DEFINITIONS
=============================================================================== */

/*===========================================================================
FUNCTION: AEEClsCreateInstance
===========================================================================*/
int AEEClsCreateInstance(AEECLSID ClsId, IShell *pIShell, IModule *po, void **ppObj)
{
	*ppObj = NULL;

	if( ClsId == AEECLSID_MYTEXT )
	{
		// Create the applet and make room for the applet structure
		if( AEEApplet_New(sizeof(mytext),
                          ClsId,
                          pIShell,
                          po,
                          (IApplet**)ppObj,
                          (AEEHANDLER)mytext_HandleEvent,
                          (PFNFREEAPPDATA)mytext_FreeAppData) ) // the FreeAppData function is called after sending EVT_APP_STOP to the HandleEvent function
                          
		{
			//Initialize applet data, this is called before sending EVT_APP_START
            // to the HandleEvent function
			if(mytext_InitAppData((mytext*)*ppObj))
			{
				//Data initialized successfully
				return(AEE_SUCCESS);
			}
			else
			{
				//Release the applet. This will free the memory allocated for the applet when
				// AEEApplet_New was called.
				IAPPLET_Release((IApplet*)*ppObj);
				return EFAILED;
			}

        } // end AEEApplet_New

    }

	return(EFAILED);
}


/*===========================================================================
FUNCTION SampleAppWizard_HandleEvent
===========================================================================*/
static boolean mytext_HandleEvent(mytext* pMe, AEEEvent eCode, uint16 wParam, uint32 dwParam)
{ 
	uint16  item;
	AECHAR  input_info[12];

	if(pMe->pMenu && IMENUCTL_HandleEvent(pMe->pMenu,eCode,wParam,dwParam))
		return TRUE;

    switch (eCode) 
	{
        // App is told it is starting up
        case EVT_APP_START:                        
		    // Add your code here...
			BuildMainMenu(pMe);
            return(TRUE);


        // App is told it is exiting
        case EVT_APP_STOP:
            // Add your code here...

      		return(TRUE);

		case EVT_CTL_TEXT_MODECHANGED:

		  return TRUE;

        // App is being suspended 
        case EVT_APP_RESUME:
		    // Add your code here...
			switch(pMe->status)
			{
			case STATUS_MENU:
				BuildMainMenu(pMe);
				break;

				break;
			case STATUS_INPUTMENU:

				break;
			}
      		return(TRUE);


        // App is being resumed
		    // Add your code here...
        case EVT_APP_SUSPEND:
			switch(pMe->status)
			{

			}

      		return(TRUE);


        // An SMS message has arrived for this app. Message is in the dwParam above as (char *)
        // sender simply uses this format "//BREW:ClassId:Message", example //BREW:0x00000001:Hello World
        case EVT_APP_MESSAGE:
		    // Add your code here...

      		return(TRUE);

        // A key was pressed. Look at the wParam above to see which key was pressed. The key
        // codes are in AEEVCodes.h. Example "AVK_1" means that the "1" key was pressed.
        case EVT_KEY:
		    // Add your code here...
			switch(wParam)
			{
			case AVK_CLR:
	
				break;
			case AVK_SELECT:
	
				break;
			}
			return(TRUE);

		case EVT_COMMAND:
		
			break;

		case EVT_CTL_TAB:
			
			  break;

        // If nothing fits up to this point then we'll just break out
        default:
            break;
   }

   return FALSE;
}


// this function is called when your application is starting up
boolean mytext_InitAppData(mytext* pMe)
{
    // Get the device information for this handset.
    // Reference all the data by looking at the pMe->DeviceInfo structure
    // Check the API reference guide for all the handy device info you can get
    pMe->DeviceInfo.wStructSize = sizeof(pMe->DeviceInfo);
    ISHELL_GetDeviceInfo(pMe->a.m_pIShell,&(pMe->DeviceInfo));

    // The display and shell interfaces are always created by
    // default, so we'll asign them so that you can access
    // them via the standard "pMe->" without the "a."
    pMe->pIDisplay = pMe->a.m_pIDisplay;
    pMe->pIShell   = pMe->a.m_pIShell;

    // Insert your code here for initializing or allocating resources...
	pMe->pMenu = NULL;
	pMe->pSingleText = NULL;
	pMe->pSoftkey1 = NULL;
	pMe->pMultiText1 = NULL;
	pMe->pMultiText2 = NULL;
	pMe->pSoftkey2 = NULL;
	pMe->pInputMenu = NULL;
	pMe->pContent1 = NULL;
	pMe->pContent2 = NULL;

    // if there have been no failures up to this point then return success
    return TRUE;
}

// this function is called when your application is exiting
void mytext_FreeAppData(mytext* pMe)
{
    // insert your code here for freeing any resources you have allocated...

    // example to use for releasing each interface:
    // if ( pMe->pIMenuCtl != NULL )         // check for NULL first
    // {
    //    IMENUCTL_Release(pMe->pIMenuCtl)   // release the interface
    //    pMe->pIMenuCtl = NULL;             // set to NULL so no problems trying to free later
    // }
    //
	if(pMe->pMenu)
	{
		IMENUCTL_Release(pMe->pMenu);
		pMe->pMenu = NULL;
	}
	if(pMe->pSingleText)
	{
		ITEXTCTL_Release(pMe->pSingleText);
		pMe->pSingleText = NULL;
	}
	if(pMe->pSoftkey1)
	{
		IMENUCTL_Release(pMe->pSoftkey1);
		pMe->pSoftkey1 = NULL;
	}
	if(pMe->pMultiText1)
	{
		ITEXTCTL_Release(pMe->pMultiText1);
		pMe->pMultiText1 = NULL;
	}
	if(pMe->pMultiText2)
	{
		ITEXTCTL_Release(pMe->pMultiText2);
		pMe->pMultiText2 = NULL;
	}
	if(pMe->pSoftkey2)
	{
		IMENUCTL_Release(pMe->pSoftkey2);
		pMe->pSoftkey2 = NULL;
	}
	if(pMe->pInputMenu)
	{
		IMENUCTL_Release(pMe->pInputMenu);
		pMe->pInputMenu = NULL;
	}
	if(pMe->pContent1)
	{
		FREE(pMe->pContent1);
		pMe->pContent1 = NULL;
	}
	if(pMe->pContent2)
	{
		FREE(pMe->pContent2);
		pMe->pContent2 = NULL;
	}
}

static void BuildMainMenu(mytext *pMe)
{
	if(!pMe->pMenu)
	{
		if(ISHELL_CreateInstance(pMe->pIShell,AEECLSID_MENUCTL,(void**)&pMe->pMenu) != SUCCESS)
			return ;
	}

	IMENUCTL_SetTitle(pMe->pMenu,MYTEXT_RES_FILE,IDS_TITLE,NULL);

	IMENUCTL_AddItem(pMe->pMenu,MYTEXT_RES_FILE,IDS_SINGLE,ID_SINGLE,NULL,0);
	IMENUCTL_AddItem(pMe->pMenu,MYTEXT_RES_FILE,IDS_MULTI,ID_MULTI,NULL,0);

	IMENUCTL_SetActive(pMe->pMenu,TRUE);
	pMe->status = STATUS_MENU;
}

